<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta name="copyright" content="(C) Copyright 2019" />
<meta name="DC.rights.owner" content="(C) Copyright 2019" />
<meta name="DC.Type" content="concept" />
<meta name="DC.Title" content="Overview of Impala Views" />
<meta name="DC.Relation" scheme="URI" content="../topics/impala_schema_objects.html" />
<meta name="prodname" content="Impala" />
<meta name="prodname" content="Impala" />
<meta name="version" content="Impala 3.3.x" />
<meta name="version" content="Impala 3.3.x" />
<meta name="DC.Format" content="XHTML" />
<meta name="DC.Identifier" content="views" />
<link rel="stylesheet" type="text/css" href="../commonltr.css" />
<title>Overview of Impala Views</title>
</head>
<body id="views">


  <h1 class="title topictitle1" id="ariaid-title1">Overview of Impala Views</h1>

  
  

  <div class="body conbody">

    <p class="p">
      Views are lightweight logical constructs that act as aliases for queries. You can specify a view name in a
      query (a <code class="ph codeph">SELECT</code> statement or the <code class="ph codeph">SELECT</code> portion of an
      <code class="ph codeph">INSERT</code> statement) where you would usually specify a table name.
    </p>


    <p class="p">
      A view lets you:
    </p>


    <ul class="ul">
      <li class="li">
        Issue complicated queries with compact and simple syntax:
<pre class="pre codeblock"><code>-- Take a complicated reporting query, plug it into a CREATE VIEW statement...
create view v1 as select c1, c2, avg(c3) from t1 group by c3 order by c1 desc limit 10;
-- ... and now you can produce the report with 1 line of code.
select * from v1;</code></pre>
      </li>


      <li class="li">
        Reduce maintenance, by avoiding the duplication of complicated queries across multiple applications in
        multiple languages:
<pre class="pre codeblock"><code>create view v2 as select t1.c1, t1.c2, t2.c3 from t1 join t2 on (t1.id = t2.id);
-- This simple query is safer to embed in reporting applications than the longer query above.
-- The view definition can remain stable even if the structure of the underlying tables changes.
select c1, c2, c3 from v2;</code></pre>
      </li>


      <li class="li">
        Build a new, more refined query on top of the original query by adding new clauses, select-list
        expressions, function calls, and so on:
<pre class="pre codeblock"><code>create view average_price_by_category as select category, avg(price) as avg_price from products group by category;
create view expensive_categories as select category, avg_price from average_price_by_category order by avg_price desc limit 10000;
create view top_10_expensive_categories as select category, avg_price from expensive_categories limit 10;</code></pre>
        This technique lets you build up several more or less granular variations of the same query, and switch
        between them when appropriate.

      </li>


      <li class="li">
        Set up aliases with intuitive names for tables, columns, result sets from joins, and so on:
<pre class="pre codeblock"><code>-- The original tables might have cryptic names inherited from a legacy system.
create view action_items as select rrptsk as assignee, treq as due_date, dmisc as notes from vxy_t1_br;
-- You can leave original names for compatibility, build new applications using more intuitive ones.
select assignee, due_date, notes from action_items;</code></pre>
      </li>


      <li class="li">
        Swap tables with others that use different file formats, partitioning schemes, and so on without any
        downtime for data copying or conversion:
<pre class="pre codeblock"><code>create table slow (x int, s string) stored as textfile;
create view report as select s from slow where x between 20 and 30;
-- Query is kind of slow due to inefficient table definition, but it works.
select * from report;

create table fast (s string) partitioned by (x int) stored as parquet;
-- ...Copy data from SLOW to FAST. Queries against REPORT view continue to work...

-- After changing the view definition, queries will be faster due to partitioning,
-- binary format, and compression in the new table.
alter view report as select s from fast where x between 20 and 30;
select * from report;</code></pre>
      </li>


      <li class="li">
        Avoid coding lengthy subqueries and repeating the same subquery text in many other queries.
      </li>


      <li class="li">
        Set up fine-grained security where a user can query some columns from a table but not other columns.
        Because <span class="keyword">Impala 2.3</span> and higher support column-level authorization, this technique is no longer
        required. If you formerly implemented column-level security through views, see
        <span class="xref">the documentation for Apache Sentry</span> for details about the column-level authorization feature.
      </li>

    </ul>


    <p class="p">
      The SQL statements that configure views are <a class="xref" href="impala_create_view.html#create_view">CREATE VIEW Statement</a>,
      <a class="xref" href="impala_alter_view.html#alter_view">ALTER VIEW Statement</a>, and <a class="xref" href="impala_drop_view.html#drop_view">DROP VIEW Statement</a>. You can
      specify view names when querying data (<a class="xref" href="impala_select.html#select">SELECT Statement</a>) and copying data from one
      table to another (<a class="xref" href="impala_insert.html#insert">INSERT Statement</a>). The <a class="xref" href="impala_with.html#with">WITH</a>
      clause creates an inline view, that only exists for the duration of a single query.
    </p>


<pre class="pre codeblock"><code>[localhost:21000] &gt; create view trivial as select * from customer;
[localhost:21000] &gt; create view some_columns as select c_first_name, c_last_name, c_login from customer;
[localhost:21000] &gt; select * from some_columns limit 5;
Query finished, fetching results ...
+--------------+-------------+---------+
| c_first_name | c_last_name | c_login |
+--------------+-------------+---------+
| Javier       | Lewis       |         |
| Amy          | Moses       |         |
| Latisha      | Hamilton    |         |
| Michael      | White       |         |
| Robert       | Moran       |         |
+--------------+-------------+---------+
[localhost:21000] &gt; create view ordered_results as select * from some_columns order by c_last_name desc, c_first_name desc limit 1000;
[localhost:21000] &gt; select * from ordered_results limit 5;
Query: select * from ordered_results limit 5
Query finished, fetching results ...
+--------------+-------------+---------+
| c_first_name | c_last_name | c_login |
+--------------+-------------+---------+
| Thomas       | Zuniga      |         |
| Sarah        | Zuniga      |         |
| Norma        | Zuniga      |         |
| Lloyd        | Zuniga      |         |
| Lisa         | Zuniga      |         |
+--------------+-------------+---------+
Returned 5 row(s) in 0.48s</code></pre>

    <p class="p">
      The previous example uses descending order for <code class="ph codeph">ORDERED_RESULTS</code> because in the sample TPCD-H
      data, there are some rows with empty strings for both <code class="ph codeph">C_FIRST_NAME</code> and
      <code class="ph codeph">C_LAST_NAME</code>, making the lowest-ordered names unuseful in a sample query.
    </p>


<pre class="pre codeblock"><code>create view visitors_by_day as select day, count(distinct visitors) as howmany from web_traffic group by day;
create view top_10_days as select day, howmany from visitors_by_day order by howmany limit 10;
select * from top_10_days;</code></pre>

    <p class="p">
        <strong class="ph b">Usage notes:</strong>
      </p>


    <div class="p">
        To see the definition of a view, issue a <code class="ph codeph">DESCRIBE FORMATTED</code> statement,
        which shows the query from the original <code class="ph codeph">CREATE VIEW</code> statement:
<pre class="pre codeblock"><code>[localhost:21000] &gt; create view v1 as select * from t1;
[localhost:21000] &gt; describe formatted v1;
Query finished, fetching results ...
+------------------------------+------------------------------+------------+
| name                         | type                         | comment    |
+------------------------------+------------------------------+------------+
| # col_name                   | data_type                    | comment    |
|                              | NULL                         | NULL       |
| x                            | int                          | None       |
| y                            | int                          | None       |
| s                            | string                       | None       |
|                              | NULL                         | NULL       |
| # Detailed Table Information | NULL                         | NULL       |
| Database:                    | views                        | NULL       |
| Owner:                       | doc_demo                     | NULL       |
| CreateTime:                  | Mon Jul 08 15:56:27 EDT 2013 | NULL       |
| LastAccessTime:              | UNKNOWN                      | NULL       |
| Protect Mode:                | None                         | NULL       |
| Retention:                   | 0                            | NULL       |
<strong class="ph b">| Table Type:                  | VIRTUAL_VIEW                 | NULL       |</strong>
| Table Parameters:            | NULL                         | NULL       |
|                              | transient_lastDdlTime        | 1373313387 |
|                              | NULL                         | NULL       |
| # Storage Information        | NULL                         | NULL       |
| SerDe Library:               | null                         | NULL       |
| InputFormat:                 | null                         | NULL       |
| OutputFormat:                | null                         | NULL       |
| Compressed:                  | No                           | NULL       |
| Num Buckets:                 | 0                            | NULL       |
| Bucket Columns:              | []                           | NULL       |
| Sort Columns:                | []                           | NULL       |
|                              | NULL                         | NULL       |
| # View Information           | NULL                         | NULL       |
<strong class="ph b">| View Original Text:          | SELECT * FROM t1             | NULL       |
| View Expanded Text:          | SELECT * FROM t1             | NULL       |</strong>
+------------------------------+------------------------------+------------+
</code></pre>
      </div>


    <p class="p">
        Prior to Impala 1.4.0, it was not possible to use the <code class="ph codeph">CREATE TABLE LIKE
        <var class="keyword varname">view_name</var></code> syntax. In Impala 1.4.0 and higher, you can create
        a table with the same column definitions as a view using the <code class="ph codeph">CREATE TABLE
        LIKE</code> technique. Although <code class="ph codeph">CREATE TABLE LIKE</code> normally inherits
        the file format of the original table, a view has no underlying file format, so
        <code class="ph codeph">CREATE TABLE LIKE <var class="keyword varname">view_name</var></code> produces a text table by
        default. To specify a different file format, include a <code class="ph codeph">STORED AS
        <var class="keyword varname">file_format</var></code> clause at the end of the <code class="ph codeph">CREATE TABLE
        LIKE</code> statement.
      </p>


    <p class="p">
        <strong class="ph b">Complex type considerations:</strong>
      </p>


    <p class="p">
        For tables containing complex type columns (<code class="ph codeph">ARRAY</code>,
        <code class="ph codeph">STRUCT</code>, or <code class="ph codeph">MAP</code>), you typically use join queries to
        refer to the complex values. You can use views to hide the join notation, making such
        tables seem like traditional denormalized tables, and making those tables queryable by
        business intelligence tools that do not have built-in support for those complex types.
        See <a class="xref" href="../shared/../topics/impala_complex_types.html#complex_types_views">Accessing Complex Type Data in Flattened Form Using Views</a> for details.
      </p>


    <p class="p">
        The <code class="ph codeph">STRAIGHT_JOIN</code> hint affects the join order of table references in
        the query block containing the hint. It does not affect the join order of nested
        queries, such as views, inline views, or <code class="ph codeph">WHERE</code>-clause subqueries. To
        use this hint for performance tuning of complex queries, apply the hint to all query
        blocks that need a fixed join order.
      </p>


    <p class="p">
        <strong class="ph b">Restrictions:</strong>
      </p>


    <ul class="ul">
      <li class="li">
        <p class="p">
          You cannot insert into an Impala view. (In some database systems, this operation is allowed and inserts
          rows into the base table.) You can use a view name on the right-hand side of an <code class="ph codeph">INSERT</code>
          statement, in the <code class="ph codeph">SELECT</code> part.
        </p>

      </li>


      <li class="li">

        <p class="p">
        If a view applies to a partitioned table, any partition pruning considers the clauses on
        both the original query and any additional <code class="ph codeph">WHERE</code> predicates in the
        query that refers to the view. Prior to Impala 1.4, only the <code class="ph codeph">WHERE</code>
        clauses on the original query from the <code class="ph codeph">CREATE VIEW</code> statement were used
        for partition pruning.
      </p>

      </li>


      <li class="li">
        <div class="p">
        An <code class="ph codeph">ORDER BY</code> clause without an additional <code class="ph codeph">LIMIT</code> clause
        is ignored in any view definition. If you need to sort the entire result set from a
        view, use an <code class="ph codeph">ORDER BY</code> clause in the <code class="ph codeph">SELECT</code> statement
        that queries the view. You can still make a simple <span class="q">"top 10"</span> report by combining the
        <code class="ph codeph">ORDER BY</code> and <code class="ph codeph">LIMIT</code> clauses in the same view
        definition:
<pre class="pre codeblock"><code>[localhost:21000] &gt; create table unsorted (x bigint);
[localhost:21000] &gt; insert into unsorted values (1), (9), (3), (7), (5), (8), (4), (6), (2);
[localhost:21000] &gt; create view sorted_view as select x from unsorted order by x;
[localhost:21000] &gt; select x from sorted_view; -- ORDER BY clause in view has no effect.
+---+
| x |
+---+
| 1 |
| 9 |
| 3 |
| 7 |
| 5 |
| 8 |
| 4 |
| 6 |
| 2 |
+---+
[localhost:21000] &gt; select x from sorted_view order by x; -- View query requires ORDER BY at outermost level.
+---+
| x |
+---+
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |
+---+
[localhost:21000] &gt; create view top_3_view as select x from unsorted order by x limit 3;
[localhost:21000] &gt; select x from top_3_view; -- ORDER BY and LIMIT together in view definition are preserved.
+---+
| x |
+---+
| 1 |
| 2 |
| 3 |
+---+
</code></pre>
      </div>

      </li>

      <li class="li">
        <p class="p">
        The <code class="ph codeph">TABLESAMPLE</code> clause of the <code class="ph codeph">SELECT</code> statement does
        not apply to a table reference derived from a view, a subquery, or anything other than a
        real base table. This clause only works for tables backed by HDFS or HDFS-like data
        files, therefore it does not apply to Kudu or HBase tables.
      </p>

      </li>

    </ul>


    <p class="p">
      <strong class="ph b">Related statements:</strong> <a class="xref" href="impala_create_view.html#create_view">CREATE VIEW Statement</a>,
      <a class="xref" href="impala_alter_view.html#alter_view">ALTER VIEW Statement</a>, <a class="xref" href="impala_drop_view.html#drop_view">DROP VIEW Statement</a>
    </p>

  </div>

<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../topics/impala_schema_objects.html">Impala Schema Objects and Object Names</a></div>
</div>
</div></body>
</html>