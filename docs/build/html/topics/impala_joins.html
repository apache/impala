<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta name="copyright" content="(C) Copyright 2018" />
<meta name="DC.rights.owner" content="(C) Copyright 2018" />
<meta name="DC.Type" content="concept" />
<meta name="DC.Title" content="Joins in Impala SELECT Statements" />
<meta name="DC.Relation" scheme="URI" content="../topics/impala_select.html" />
<meta name="prodname" content="Impala" />
<meta name="prodname" content="Impala" />
<meta name="version" content="Impala 3.0.x" />
<meta name="version" content="Impala 3.0.x" />
<meta name="DC.Format" content="XHTML" />
<meta name="DC.Identifier" content="joins" />
<link rel="stylesheet" type="text/css" href="../commonltr.css" />
<title>Joins in Impala SELECT Statements</title>
</head>
<body id="joins">


  <h1 class="title topictitle1" id="ariaid-title1">Joins in Impala SELECT Statements</h1>

  
  

  <div class="body conbody">

    <p class="p">
      
      A join query is a <code class="ph codeph">SELECT</code> statement that combines data from two or more tables,
      and returns a result set containing items from some or all of those tables. It is a way to
      cross-reference and correlate related data that is organized into multiple tables, typically
      using identifiers that are repeated in each of the joined tables.
    </p>


    <p class="p">
        <strong class="ph b">Syntax:</strong>
      </p>


    <p class="p">
        Impala supports a wide variety of <code class="ph codeph">JOIN</code> clauses. Left, right, semi, full, and outer joins
        are supported in all Impala versions. The <code class="ph codeph">CROSS JOIN</code> operator is available in Impala 1.2.2
        and higher. During performance tuning, you can override the reordering of join clauses that Impala does
        internally by including the keyword <code class="ph codeph">STRAIGHT_JOIN</code> immediately after the
        <code class="ph codeph">SELECT</code> and any <code class="ph codeph">DISTINCT</code> or <code class="ph codeph">ALL</code> keywords.
      </p>


<pre class="pre codeblock"><code>SELECT <var class="keyword varname">select_list</var> FROM
  <var class="keyword varname">table_or_subquery1</var> [INNER] JOIN <var class="keyword varname">table_or_subquery2</var> |
  <var class="keyword varname">table_or_subquery1</var> {LEFT [OUTER] | RIGHT [OUTER] | FULL [OUTER]} JOIN <var class="keyword varname">table_or_subquery2</var> |
  <var class="keyword varname">table_or_subquery1</var> {LEFT | RIGHT} SEMI JOIN <var class="keyword varname">table_or_subquery2</var> |
  <span class="ph"><var class="keyword varname">table_or_subquery1</var> {LEFT | RIGHT} ANTI JOIN <var class="keyword varname">table_or_subquery2</var> |</span>
    [ ON <var class="keyword varname">col1</var> = <var class="keyword varname">col2</var> [AND <var class="keyword varname">col3</var> = <var class="keyword varname">col4</var> ...] |
      USING (<var class="keyword varname">col1</var> [, <var class="keyword varname">col2</var> ...]) ]
  [<var class="keyword varname">other_join_clause</var> ...]
[ WHERE <var class="keyword varname">where_clauses</var> ]

SELECT <var class="keyword varname">select_list</var> FROM
  <var class="keyword varname">table_or_subquery1</var>, <var class="keyword varname">table_or_subquery2</var> [, <var class="keyword varname">table_or_subquery3</var> ...]
  [<var class="keyword varname">other_join_clause</var> ...]
WHERE
    <var class="keyword varname">col1</var> = <var class="keyword varname">col2</var> [AND <var class="keyword varname">col3</var> = <var class="keyword varname">col4</var> ...]

SELECT <var class="keyword varname">select_list</var> FROM
  <var class="keyword varname">table_or_subquery1</var> CROSS JOIN <var class="keyword varname">table_or_subquery2</var>
  [<var class="keyword varname">other_join_clause</var> ...]
[ WHERE <var class="keyword varname">where_clauses</var> ]</code></pre>

    <p class="p">
      <strong class="ph b">SQL-92 and SQL-89 Joins:</strong>
    </p>


    <p class="p">
      Queries with the explicit <code class="ph codeph">JOIN</code> keywords are known as SQL-92 style joins, referring to the
      level of the SQL standard where they were introduced. The corresponding <code class="ph codeph">ON</code> or
      <code class="ph codeph">USING</code> clauses clearly show which columns are used as the join keys in each case:
    </p>


<pre class="pre codeblock"><code>SELECT t1.c1, t2.c2 FROM <strong class="ph b">t1 JOIN t2</strong>
  <strong class="ph b">ON t1.id = t2.id and t1.type_flag = t2.type_flag</strong>
  WHERE t1.c1 &gt; 100;

SELECT t1.c1, t2.c2 FROM <strong class="ph b">t1 JOIN t2</strong>
  <strong class="ph b">USING (id, type_flag)</strong>
  WHERE t1.c1 &gt; 100;</code></pre>

    <p class="p">
      The <code class="ph codeph">ON</code> clause is a general way to compare columns across the two tables, even if the column
      names are different. The <code class="ph codeph">USING</code> clause is a shorthand notation for specifying the join
      columns, when the column names are the same in both tables. You can code equivalent <code class="ph codeph">WHERE</code>
      clauses that compare the columns, instead of <code class="ph codeph">ON</code> or <code class="ph codeph">USING</code> clauses, but that
      practice is not recommended because mixing the join comparisons with other filtering clauses is typically
      less readable and harder to maintain.
    </p>


    <p class="p">
      Queries with a comma-separated list of tables and subqueries are known as SQL-89 style joins. In these
      queries, the equality comparisons between columns of the joined tables go in the <code class="ph codeph">WHERE</code>
      clause alongside other kinds of comparisons. This syntax is easy to learn, but it is also easy to
      accidentally remove a <code class="ph codeph">WHERE</code> clause needed for the join to work correctly.
    </p>


<pre class="pre codeblock"><code>SELECT t1.c1, t2.c2 FROM <strong class="ph b">t1, t2</strong>
  WHERE
  <strong class="ph b">t1.id = t2.id AND t1.type_flag = t2.type_flag</strong>
  AND t1.c1 &gt; 100;</code></pre>

    <p class="p">
      <strong class="ph b">Self-joins:</strong>
    </p>


    <p class="p">
      Impala can do self-joins, for example to join on two different columns in the same table to represent
      parent-child relationships or other tree-structured data. There is no explicit syntax for this; just use the
      same table name for both the left-hand and right-hand table, and assign different table aliases to use when
      referring to the fully qualified column names:
    </p>


<pre class="pre codeblock"><code>-- Combine fields from both parent and child rows.
SELECT lhs.id, rhs.parent, lhs.c1, rhs.c2 FROM tree_data lhs, tree_data rhs WHERE lhs.id = rhs.parent;</code></pre>

    <p class="p">
      <strong class="ph b">Cartesian joins:</strong>
    </p>


    <div class="p">
      To avoid producing huge result sets by mistake, Impala does not allow Cartesian joins of the form:
<pre class="pre codeblock"><code>SELECT ... FROM t1 JOIN t2;
SELECT ... FROM t1, t2;</code></pre>
      If you intend to join the tables based on common values, add <code class="ph codeph">ON</code> or <code class="ph codeph">WHERE</code>
      clauses to compare columns across the tables. If you truly intend to do a Cartesian join, use the
      <code class="ph codeph">CROSS JOIN</code> keyword as the join operator. The <code class="ph codeph">CROSS JOIN</code> form does not use
      any <code class="ph codeph">ON</code> clause, because it produces a result set with all combinations of rows from the
      left-hand and right-hand tables. The result set can still be filtered by subsequent <code class="ph codeph">WHERE</code>
      clauses. For example:
    </div>


<pre class="pre codeblock"><code>SELECT ... FROM t1 CROSS JOIN t2;
SELECT ... FROM t1 CROSS JOIN t2 WHERE <var class="keyword varname">tests_on_non_join_columns</var>;</code></pre>

    <p class="p">
      <strong class="ph b">Inner and outer joins:</strong>
    </p>


    <p class="p">
      An inner join is the most common and familiar type: rows in the result set contain the requested columns from
      the appropriate tables, for all combinations of rows where the join columns of the tables have identical
      values. If a column with the same name occurs in both tables, use a fully qualified name or a column alias to
      refer to the column in the select list or other clauses. Impala performs inner joins by default for both
      SQL-89 and SQL-92 join syntax:
    </p>


<pre class="pre codeblock"><code>-- The following 3 forms are all equivalent.
SELECT t1.id, c1, c2 FROM t1, t2 WHERE t1.id = t2.id;
SELECT t1.id, c1, c2 FROM t1 JOIN t2 ON t1.id = t2.id;
SELECT t1.id, c1, c2 FROM t1 INNER JOIN t2 ON t1.id = t2.id;</code></pre>

    <p class="p">
      An outer join retrieves all rows from the left-hand table, or the right-hand table, or both; wherever there
      is no matching data in the table on the other side of the join, the corresponding columns in the result set
      are set to <code class="ph codeph">NULL</code>. To perform an outer join, include the <code class="ph codeph">OUTER</code> keyword in the
      join operator, along with either <code class="ph codeph">LEFT</code>, <code class="ph codeph">RIGHT</code>, or <code class="ph codeph">FULL</code>:
    </p>


<pre class="pre codeblock"><code>SELECT * FROM t1 LEFT OUTER JOIN t2 ON t1.id = t2.id;
SELECT * FROM t1 RIGHT OUTER JOIN t2 ON t1.id = t2.id;
SELECT * FROM t1 FULL OUTER JOIN t2 ON t1.id = t2.id;</code></pre>

    <p class="p">
      For outer joins, Impala requires SQL-92 syntax; that is, the <code class="ph codeph">JOIN</code> keyword instead of
      comma-separated table names. Impala does not support vendor extensions such as <code class="ph codeph">(+)</code> or
      <code class="ph codeph">*=</code> notation for doing outer joins with SQL-89 query syntax.
    </p>


    <p class="p">
      <strong class="ph b">Equijoins and Non-Equijoins:</strong>
    </p>


    <p class="p">
      By default, Impala requires an equality comparison between the left-hand and right-hand tables, either
      through <code class="ph codeph">ON</code>, <code class="ph codeph">USING</code>, or <code class="ph codeph">WHERE</code> clauses. These types of
      queries are classified broadly as equijoins. Inner, outer, full, and semi joins can all be equijoins based on
      the presence of equality tests between columns in the left-hand and right-hand tables.
    </p>


    <p class="p">
      In Impala 1.2.2 and higher, non-equijoin queries are also possible, with comparisons such as
      <code class="ph codeph">!=</code> or <code class="ph codeph">&lt;</code> between the join columns. These kinds of queries require care to
      avoid producing huge result sets that could exceed resource limits. Once you have planned a non-equijoin
      query that produces a result set of acceptable size, you can code the query using the <code class="ph codeph">CROSS
      JOIN</code> operator, and add the extra comparisons in the <code class="ph codeph">WHERE</code> clause:
    </p>


<pre class="pre codeblock"><code>SELECT * FROM t1 CROSS JOIN t2 WHERE t1.total &gt; t2.maximum_price;</code></pre>

    <p class="p">
      In <span class="keyword">Impala 2.3</span> and higher, additional non-equijoin queries are possible due to the addition
      of nested loop joins. These queries typically involve <code class="ph codeph">SEMI JOIN</code>,
      <code class="ph codeph">ANTI JOIN</code>, or <code class="ph codeph">FULL OUTER JOIN</code> clauses.
      Impala sometimes also uses nested loop joins internally when evaluating <code class="ph codeph">OUTER JOIN</code>
      queries involving complex type columns.
      Query phases involving nested loop joins do not use the spill-to-disk mechanism if they
      exceed the memory limit. Impala decides internally when to use each join mechanism; you cannot
      specify any query hint to choose between the nested loop join or the original hash join algorithm.
    </p>


<pre class="pre codeblock"><code>SELECT * FROM t1 LEFT OUTER JOIN t2 ON t1.int_col &lt; t2.int_col;</code></pre>

    <p class="p">
      <strong class="ph b">Semi-joins:</strong>
    </p>


    <p class="p">
      Semi-joins are a relatively rarely used variation. With the left semi-join, only data from the left-hand
      table is returned, for rows where there is matching data in the right-hand table, based on comparisons
      between join columns in <code class="ph codeph">ON</code> or <code class="ph codeph">WHERE</code> clauses. Only one instance of each row
      from the left-hand table is returned, regardless of how many matching rows exist in the right-hand table.
      <span class="ph">A right semi-join (available in Impala 2.0 and higher) reverses the comparison and returns
      data from the right-hand table.</span>
    </p>


<pre class="pre codeblock"><code>SELECT t1.c1, t1.c2, t1.c2 FROM t1 LEFT SEMI JOIN t2 ON t1.id = t2.id;</code></pre>

    <p class="p">
      <strong class="ph b">Natural joins (not supported):</strong>
    </p>


    <p class="p">
      Impala does not support the <code class="ph codeph">NATURAL JOIN</code> operator, again to avoid inconsistent or huge
      result sets. Natural joins do away with the <code class="ph codeph">ON</code> and <code class="ph codeph">USING</code> clauses, and
      instead automatically join on all columns with the same names in the left-hand and right-hand tables. This
      kind of query is not recommended for rapidly evolving data structures such as are typically used in Hadoop.
      Thus, Impala does not support the <code class="ph codeph">NATURAL JOIN</code> syntax, which can produce different query
      results as columns are added to or removed from tables.
    </p>


    <p class="p">
      If you do have any queries that use <code class="ph codeph">NATURAL JOIN</code>, make sure to rewrite them with explicit
      <code class="ph codeph">USING</code> clauses, because Impala could interpret the <code class="ph codeph">NATURAL</code> keyword as a
      table alias:
    </p>


<pre class="pre codeblock"><code>-- 'NATURAL' is interpreted as an alias for 't1' and Impala attempts an inner join,
-- resulting in an error because inner joins require explicit comparisons between columns.
SELECT t1.c1, t2.c2 FROM t1 NATURAL JOIN t2;
ERROR: NotImplementedException: Join with 't2' requires at least one conjunctive equality predicate.
  To perform a Cartesian product between two tables, use a CROSS JOIN.

-- If you expect the tables to have identically named columns with matching values,
-- list the corresponding column names in a USING clause.
SELECT t1.c1, t2.c2 FROM t1 JOIN t2 USING (id, type_flag, name, address);</code></pre>

    <p class="p">
      <strong class="ph b">Anti-joins (<span class="keyword">Impala 2.0</span> and higher only):</strong>
    </p>


    <p class="p">
      Impala supports the <code class="ph codeph">LEFT ANTI JOIN</code> and <code class="ph codeph">RIGHT ANTI JOIN</code> clauses in
      <span class="keyword">Impala 2.0</span> and higher. The <code class="ph codeph">LEFT</code> or <code class="ph codeph">RIGHT</code>
      keyword is required for this kind of join. For <code class="ph codeph">LEFT ANTI JOIN</code>, this clause returns those
      values from the left-hand table that have no matching value in the right-hand table. <code class="ph codeph">RIGHT ANTI
      JOIN</code> reverses the comparison and returns values from the right-hand table. You can express this
      negative relationship either through the <code class="ph codeph">ANTI JOIN</code> clause or through a <code class="ph codeph">NOT
      EXISTS</code> operator with a subquery.
    </p>




    <p class="p">
        <strong class="ph b">Complex type considerations:</strong>
      </p>




    <p class="p">
      When referring to a column with a complex type (<code class="ph codeph">STRUCT</code>, <code class="ph codeph">ARRAY</code>, or <code class="ph codeph">MAP</code>)
      in a query, you use join notation to <span class="q">"unpack"</span> the scalar fields of the struct, the elements of the array, or
      the key-value pairs of the map. (The join notation is not required for aggregation operations, such as
      <code class="ph codeph">COUNT()</code> or <code class="ph codeph">SUM()</code> for array elements.) Because Impala recognizes which complex type elements are associated with which row
      of the result set, you use the same syntax as for a cross or cartesian join, without an explicit join condition.
      See <a class="xref" href="impala_complex_types.html#complex_types">Complex Types (Impala 2.3 or higher only)</a> for details about Impala support for complex types.
    </p>


    <p class="p">
        <strong class="ph b">Usage notes:</strong>
      </p>


    <p class="p">
      You typically use join queries in situations like these:
    </p>


    <ul class="ul">
      <li class="li">
        When related data arrives from different sources, with each data set physically residing in a separate
        table. For example, you might have address data from business records that you cross-check against phone
        listings or census data.
        <div class="note note"><span class="notetitle">Note:</span>
          Impala can join tables of different file formats, including Impala-managed tables and HBase tables. For
          example, you might keep small dimension tables in HBase, for convenience of single-row lookups and
          updates, and for the larger fact tables use Parquet or other binary file format optimized for scan
          operations. Then, you can issue a join query to cross-reference the fact tables with the dimension
          tables.
        </div>

      </li>


      <li class="li">
        When data is normalized, a technique for reducing data duplication by dividing it across multiple tables.
        This kind of organization is often found in data that comes from traditional relational database systems.
        For example, instead of repeating some long string such as a customer name in multiple tables, each table
        might contain a numeric customer ID. Queries that need to display the customer name could <span class="q">"join"</span> the
        table that specifies which customer ID corresponds to which name.
      </li>


      <li class="li">
        When certain columns are rarely needed for queries, so they are moved into separate tables to reduce
        overhead for common queries. For example, a <code class="ph codeph">biography</code> field might be rarely needed in
        queries on employee data. Putting that field in a separate table reduces the amount of I/O for common
        queries on employee addresses or phone numbers. Queries that do need the <code class="ph codeph">biography</code> column
        can retrieve it by performing a join with that separate table.
      </li>


      <li class="li">
        In <span class="keyword">Impala 2.3</span> or higher, when referring to complex type columns in queries.
        See <a class="xref" href="impala_complex_types.html#complex_types">Complex Types (Impala 2.3 or higher only)</a> for details.
      </li>

    </ul>


    <p class="p">
      When comparing columns with the same names in <code class="ph codeph">ON</code> or <code class="ph codeph">WHERE</code> clauses, use the
      fully qualified names such as <code class="ph codeph"><var class="keyword varname">db_name</var>.<var class="keyword varname">table_name</var></code>, or
      assign table aliases, column aliases, or both to make the code more compact and understandable:
    </p>


<pre class="pre codeblock"><code>select t1.c1 as first_id, t2.c2 as second_id from
  t1 join t2 on first_id = second_id;

select fact.custno, dimension.custno from
  customer_data as fact join customer_address as dimension
  using (custno)</code></pre>

    <div class="note note"><span class="notetitle">Note:</span>
      <p class="p">
        Performance for join queries is a crucial aspect for Impala, because complex join queries are
        resource-intensive operations. An efficient join query produces much less network traffic and CPU overhead
        than an inefficient one. For best results:
      </p>

      <ul class="ul">
        <li class="li">
          Make sure that both <a class="xref" href="impala_perf_stats.html#perf_stats">table and column statistics</a> are
          available for all the tables involved in a join query, and especially for the columns referenced in any
          join conditions. Impala uses the statistics to automatically deduce an efficient join order.
          Use <a class="xref" href="impala_show.html#show"><code class="ph codeph">SHOW TABLE STATS <var class="keyword varname">table_name</var></code> and
          <code class="ph codeph">SHOW COLUMN STATS <var class="keyword varname">table_name</var></code></a> to check if statistics are
          already present. Issue the <code class="ph codeph">COMPUTE STATS <var class="keyword varname">table_name</var></code> for a nonpartitioned table,
          or (in Impala 2.1.0 and higher) <code class="ph codeph">COMPUTE INCREMENTAL STATS <var class="keyword varname">table_name</var></code>
          for a partitioned table, to collect the initial statistics at both the table and column levels, and to keep the
          statistics up to date after any substantial <code class="ph codeph">INSERT</code> or <code class="ph codeph">LOAD DATA</code> operations.
        </li>


        <li class="li">
          If table or column statistics are not available, join the largest table first. You can check the
          existence of statistics with the <code class="ph codeph">SHOW TABLE STATS <var class="keyword varname">table_name</var></code> and
          <code class="ph codeph">SHOW COLUMN STATS <var class="keyword varname">table_name</var></code> statements.
        </li>


        <li class="li">
          If table or column statistics are not available, join subsequent tables according to which table has the
          most selective filter, based on overall size and <code class="ph codeph">WHERE</code> clauses. Joining the table with
          the most selective filter results in the fewest number of rows being returned.
        </li>

      </ul>

      <p class="p">
        For more information and examples of performance for join queries, see
        <a class="xref" href="impala_perf_joins.html#perf_joins">Performance Considerations for Join Queries</a>.
      </p>

    </div>


    <p class="p">
      To control the result set from a join query, include the names of corresponding column names in both tables
      in an <code class="ph codeph">ON</code> or <code class="ph codeph">USING</code> clause, or by coding equality comparisons for those
      columns in the <code class="ph codeph">WHERE</code> clause.
    </p>


<pre class="pre codeblock"><code>[localhost:21000] &gt; select c_last_name, ca_city from customer join customer_address where c_customer_sk = ca_address_sk;
+-------------+-----------------+
| c_last_name | ca_city         |
+-------------+-----------------+
| Lewis       | Fairfield       |
| Moses       | Fairview        |
| Hamilton    | Pleasant Valley |
| White       | Oak Ridge       |
| Moran       | Glendale        |
...
| Richards    | Lakewood         |
| Day         | Lebanon          |
| Painter     | Oak Hill         |
| Bentley     | Greenfield       |
| Jones       | Stringtown       |
+-------------+------------------+
Returned 50000 row(s) in 9.82s</code></pre>

    <p class="p">
      One potential downside of joins is the possibility of excess resource usage in poorly constructed queries.
      Impala imposes restrictions on join queries to guard against such issues. To minimize the chance of runaway
      queries on large data sets, Impala requires every join query to contain at least one equality predicate
      between the columns of the various tables. For example, if <code class="ph codeph">T1</code> contains 1000 rows and
      <code class="ph codeph">T2</code> contains 1,000,000 rows, a query <code class="ph codeph">SELECT <var class="keyword varname">columns</var> FROM t1 JOIN
      t2</code> could return up to 1 billion rows (1000 * 1,000,000); Impala requires that the query include a
      clause such as <code class="ph codeph">ON t1.c1 = t2.c2</code> or <code class="ph codeph">WHERE t1.c1 = t2.c2</code>.
    </p>


    <p class="p">
      Because even with equality clauses, the result set can still be large, as we saw in the previous example, you
      might use a <code class="ph codeph">LIMIT</code> clause to return a subset of the results:
    </p>


<pre class="pre codeblock"><code>[localhost:21000] &gt; select c_last_name, ca_city from customer, customer_address where c_customer_sk = ca_address_sk limit 10;
+-------------+-----------------+
| c_last_name | ca_city         |
+-------------+-----------------+
| Lewis       | Fairfield       |
| Moses       | Fairview        |
| Hamilton    | Pleasant Valley |
| White       | Oak Ridge       |
| Moran       | Glendale        |
| Sharp       | Lakeview        |
| Wiles       | Farmington      |
| Shipman     | Union           |
| Gilbert     | New Hope        |
| Brunson     | Martinsville    |
+-------------+-----------------+
Returned 10 row(s) in 0.63s</code></pre>

    <p class="p">
      Or you might use additional comparison operators or aggregation functions to condense a large result set into
      a smaller set of values:
    </p>


<pre class="pre codeblock"><code>[localhost:21000] &gt; -- Find the names of customers who live in one particular town.
[localhost:21000] &gt; select distinct c_last_name from customer, customer_address where
  c_customer_sk = ca_address_sk
  and ca_city = "Green Acres";
+---------------+
| c_last_name   |
+---------------+
| Hensley       |
| Pearson       |
| Mayer         |
| Montgomery    |
| Ricks         |
...
| Barrett       |
| Price         |
| Hill          |
| Hansen        |
| Meeks         |
+---------------+
Returned 332 row(s) in 0.97s

[localhost:21000] &gt; -- See how many different customers in this town have names starting with "A".
[localhost:21000] &gt; select count(distinct c_last_name) from customer, customer_address where
  c_customer_sk = ca_address_sk
  and ca_city = "Green Acres"
  and substr(c_last_name,1,1) = "A";
+-----------------------------+
| count(distinct c_last_name) |
+-----------------------------+
| 12                          |
+-----------------------------+
Returned 1 row(s) in 1.00s</code></pre>

    <p class="p">
      Because a join query can involve reading large amounts of data from disk, sending large amounts of data
      across the network, and loading large amounts of data into memory to do the comparisons and filtering, you
      might do benchmarking, performance analysis, and query tuning to find the most efficient join queries for
      your data set, hardware capacity, network configuration, and cluster workload.
    </p>


    <p class="p">
      The two categories of joins in Impala are known as <strong class="ph b">partitioned joins</strong> and <strong class="ph b">broadcast joins</strong>. If
      inaccurate table or column statistics, or some quirk of the data distribution, causes Impala to choose the
      wrong mechanism for a particular join, consider using query hints as a temporary workaround. For details, see
      <a class="xref" href="impala_hints.html#hints">Optimizer Hints</a>.
    </p>


    <p class="p">
      <strong class="ph b">Handling NULLs in Join Columns:</strong>
    </p>


    <p class="p">
      By default, join key columns do not match if either one contains a <code class="ph codeph">NULL</code> value.
      To treat such columns as equal if both contain <code class="ph codeph">NULL</code>, you can use an expression
      such as <code class="ph codeph">A = B OR (A IS NULL AND B IS NULL)</code>.
      In <span class="keyword">Impala 2.5</span> and higher, the <code class="ph codeph">&lt;=&gt;</code> operator (shorthand for
      <code class="ph codeph">IS NOT DISTINCT FROM</code>) performs the same comparison in a concise and efficient form.
      The <code class="ph codeph">&lt;=&gt;</code> operator is more efficient in for comparing join keys in a <code class="ph codeph">NULL</code>-safe
      manner, because the operator can use a hash join while the <code class="ph codeph">OR</code> expression cannot.
    </p>


    <p class="p">
        <strong class="ph b">Examples:</strong>
      </p>


    <div class="p">
      The following examples refer to these simple tables containing small sets of integers:
<pre class="pre codeblock"><code>[localhost:21000] &gt; create table t1 (x int);
[localhost:21000] &gt; insert into t1 values (1), (2), (3), (4), (5), (6);

[localhost:21000] &gt; create table t2 (y int);
[localhost:21000] &gt; insert into t2 values (2), (4), (6);

[localhost:21000] &gt; create table t3 (z int);
[localhost:21000] &gt; insert into t3 values (1), (3), (5);
</code></pre>
    </div>




    <p class="p">
      The following example demonstrates an anti-join, returning the values from <code class="ph codeph">T1</code> that do not
      exist in <code class="ph codeph">T2</code> (in this case, the odd numbers 1, 3, and 5):
    </p>


<pre class="pre codeblock"><code>[localhost:21000] &gt; select x from t1 left anti join t2 on (t1.x = t2.y);
+---+
| x |
+---+
| 1 |
| 3 |
| 5 |
+---+
</code></pre>

    <p class="p">
        <strong class="ph b">Related information:</strong>
      </p>


    <p class="p">
      See these tutorials for examples of different kinds of joins:
    </p>


    <ul class="ul">
      <li class="li">
        <a class="xref" href="impala_tutorial.html#tut_cross_join">Cross Joins and Cartesian Products with the CROSS JOIN Operator</a>
      </li>

    </ul>

  </div>

<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../topics/impala_select.html">SELECT Statement</a></div>
</div>
</div></body>
</html>