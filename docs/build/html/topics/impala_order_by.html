<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta name="copyright" content="(C) Copyright 2019" />
<meta name="DC.rights.owner" content="(C) Copyright 2019" />
<meta name="DC.Type" content="concept" />
<meta name="DC.Title" content="ORDER BY Clause" />
<meta name="DC.Relation" scheme="URI" content="../topics/impala_select.html" />
<meta name="prodname" content="Impala" />
<meta name="prodname" content="Impala" />
<meta name="version" content="Impala 3.3.x" />
<meta name="version" content="Impala 3.3.x" />
<meta name="DC.Format" content="XHTML" />
<meta name="DC.Identifier" content="order_by" />
<link rel="stylesheet" type="text/css" href="../commonltr.css" />
<title>ORDER BY Clause</title>
</head>
<body id="order_by">


  <h1 class="title topictitle1" id="ariaid-title1">ORDER BY Clause</h1>

  

  <div class="body conbody">

    <p class="p"> The <code class="ph codeph">ORDER BY</code> clause of a <code class="ph codeph">SELECT</code>
      statement sorts the result set based on the values from one or more
      columns. </p>


    <p class="p"> First, data is sorted locally by each <code class="ph codeph">impalad</code> daemon,
      then streamed to the coordinator daemon, which merges the sorted result
      sets. For distributed queries, this is a relatively expensive operation
      and can require more memory capacity than a query without <code class="ph codeph">ORDER
        BY</code>. Even if the query takes approximately the same time to
      finish with or without the <code class="ph codeph">ORDER BY</code> clause, subjectively
      it can appear slower because no results are available until all processing
      is finished, rather than results coming back gradually as rows matching
      the <code class="ph codeph">WHERE</code> clause are found. Therefore, if you only need
      the first N results from the sorted result set, also include the
        <code class="ph codeph">LIMIT</code> clause, which reduces network overhead and the
      memory requirement on the coordinator node. </p>


    <p class="p">
        <strong class="ph b">Syntax:</strong>
      </p>


    <p class="p">
      The full syntax for the <code class="ph codeph">ORDER BY</code> clause is:
    </p>


<pre class="pre codeblock"><code>ORDER BY <var class="keyword varname">col_ref</var> [, <var class="keyword varname">col_ref</var> ...] [ASC | DESC] [NULLS FIRST | NULLS LAST]

col_ref ::= <var class="keyword varname">column_name</var> | <var class="keyword varname">integer_literal</var>
</code></pre>

    <p class="p">
      Although the most common usage is <code class="ph codeph">ORDER BY <var class="keyword varname">column_name</var></code>, you can also
      specify <code class="ph codeph">ORDER BY 1</code> to sort by the first column of the result set, <code class="ph codeph">ORDER BY
      2</code> to sort by the second column, and so on. The number must be a numeric literal, not some other kind
      of constant expression. (If the argument is some other expression, even a <code class="ph codeph">STRING</code> value, the
      query succeeds but the order of results is undefined.)
    </p>


    <p class="p">
      <code class="ph codeph">ORDER BY <var class="keyword varname">column_number</var></code> can only be used when the query explicitly lists
      the columns in the <code class="ph codeph">SELECT</code> list, not with <code class="ph codeph">SELECT *</code> queries.
    </p>


    <p class="p">
      <strong class="ph b">Ascending and descending sorts:</strong>
    </p>


    <p class="p">
      The default sort order (the same as using the <code class="ph codeph">ASC</code> keyword) puts the smallest values at the
      start of the result set, and the largest values at the end. Specifying the <code class="ph codeph">DESC</code> keyword
      reverses that order.
    </p>


    <p class="p">
      <strong class="ph b">Sort order for NULL values:</strong>
    </p>


    <p class="p">
      See <a class="xref" href="impala_literals.html#null">NULL</a> for details about how <code class="ph codeph">NULL</code> values are positioned
      in the sorted result set, and how to use the <code class="ph codeph">NULLS FIRST</code> and <code class="ph codeph">NULLS LAST</code>
      clauses. (The sort position for <code class="ph codeph">NULL</code> values in <code class="ph codeph">ORDER BY ... DESC</code> queries is
      changed in Impala 1.2.1 and higher to be more standards-compliant, and the <code class="ph codeph">NULLS FIRST</code> and
      <code class="ph codeph">NULLS LAST</code> keywords are new in Impala 1.2.1.)
    </p>


    <p class="p">
        Prior to Impala 1.4.0, Impala required any query including an
        <code class="ph codeph"><a class="xref" href="../shared/../topics/impala_order_by.html#order_by">ORDER BY</a></code>
        clause to also use a
        <code class="ph codeph"><a class="xref" href="../shared/../topics/impala_limit.html#limit">LIMIT</a></code> clause. In
        Impala 1.4.0 and higher, the <code class="ph codeph">LIMIT</code> clause is optional for <code class="ph codeph">ORDER
        BY</code> queries. In cases where sorting a huge result set requires enough memory to
        exceed the Impala memory limit for a particular executor Impala daemon, Impala
        automatically uses a temporary disk work area to perform the sort operation.
      </p>

    <p class="p">
        <strong class="ph b">Complex type considerations:</strong>
      </p>


    <p class="p">
      In <span class="keyword">Impala 2.3</span> and higher, the complex data types <code class="ph codeph">STRUCT</code>,
      <code class="ph codeph">ARRAY</code>, and <code class="ph codeph">MAP</code> are available. These columns cannot
      be referenced directly in the <code class="ph codeph">ORDER BY</code> clause.
      When you query a complex type column, you use join notation to <span class="q">"unpack"</span> the elements
      of the complex type, and within the join query you can include an <code class="ph codeph">ORDER BY</code>
      clause to control the order in the result set of the scalar elements from the complex type.
      See <a class="xref" href="impala_complex_types.html#complex_types">Complex Types (Impala 2.3 or higher only)</a> for details about Impala support for complex types.
    </p>


    <p class="p">
      The following query shows how a complex type column cannot be directly used in an <code class="ph codeph">ORDER BY</code> clause:
    </p>


<pre class="pre codeblock"><code>CREATE TABLE games (id BIGINT, score ARRAY &lt;BIGINT&gt;) STORED AS PARQUET;
...use LOAD DATA to load externally created Parquet files into the table...
SELECT id FROM games ORDER BY score DESC;
ERROR: AnalysisException: ORDER BY expression 'score' with complex type 'ARRAY&lt;BIGINT&gt;' is not supported.
</code></pre>

    <p class="p">
        <strong class="ph b">Examples:</strong>
      </p>


    <p class="p"> The following query retrieves the user ID and score, only for scores
      greater than one million, with the highest scores for each user listed
      first. Because the individual array elements are now represented as
      separate rows in the result set, they can be used in the <code class="ph codeph">ORDER
        BY</code> clause, referenced using the <code class="ph codeph">ITEM</code>
      pseudo-column that represents each array element. </p>


<pre class="pre codeblock"><code>SELECT id, item FROM games, games.score
  WHERE item &gt; 1000000
ORDER BY id, item desc;
</code></pre>

    <p class="p">
      The following queries use similar <code class="ph codeph">ORDER BY</code> techniques with variations of the <code class="ph codeph">GAMES</code>
      table, where the complex type is an <code class="ph codeph">ARRAY</code> containing <code class="ph codeph">STRUCT</code> or <code class="ph codeph">MAP</code>
      elements to represent additional details about each game that was played.
      For an array of structures, the fields of the structure are referenced as <code class="ph codeph">ITEM.<var class="keyword varname">field_name</var></code>.
      For an array of maps, the keys and values within each array element are referenced as <code class="ph codeph">ITEM.KEY</code>
      and <code class="ph codeph">ITEM.VALUE</code>.
    </p>


<pre class="pre codeblock"><code>CREATE TABLE games2 (id BIGINT, play array &lt; struct &lt;game_name: string, score: BIGINT, high_score: boolean&gt; &gt;) STORED AS PARQUET
...use LOAD DATA to load externally created Parquet files into the table...
SELECT id, item.game_name, item.score FROM games2, games2.play
  WHERE item.score &gt; 1000000
ORDER BY id, item.score DESC;

CREATE TABLE games3 (id BIGINT, play ARRAY &lt; MAP &lt;STRING, BIGINT&gt; &gt;) STORED AS PARQUET;
...use LOAD DATA to load externally created Parquet files into the table...
SELECT id, info.key AS k, info.value AS v from games3, games3.play AS plays, games3.play.item AS info
  WHERE info.KEY = 'score' AND info.VALUE &gt; 1000000
ORDER BY id, info.value desc;
</code></pre>

    <p class="p">
        <strong class="ph b">Usage notes:</strong>
      </p>


    <p class="p"> Although the <code class="ph codeph">LIMIT</code> clause is now optional on
        <code class="ph codeph">ORDER BY</code> queries, if your query only needs some number
      of rows that you can predict in advance, use the <code class="ph codeph">LIMIT</code>
      clause to reduce unnecessary processing. For example, if the query has a
      clause <code class="ph codeph">LIMIT 10</code>, each executor Impala daemon sorts its
      portion of the relevant result set and only returns 10 rows to the
      coordinator node. The coordinator node picks the 10 highest or lowest row
      values out of this small intermediate result set. </p>


    <p class="p">
      If an <code class="ph codeph">ORDER BY</code> clause is applied to an early phase of query processing, such as a subquery
      or a view definition, Impala ignores the <code class="ph codeph">ORDER BY</code> clause. To get ordered results from a
      subquery or view, apply an <code class="ph codeph">ORDER BY</code> clause to the outermost or final <code class="ph codeph">SELECT</code>
      level.
    </p>


    <p class="p">
      <code class="ph codeph">ORDER BY</code> is often used in combination with <code class="ph codeph">LIMIT</code> to perform <span class="q">"top-N"</span>
      queries:
    </p>


<pre class="pre codeblock"><code>SELECT user_id AS "Top 10 Visitors", SUM(page_views) FROM web_stats
  GROUP BY page_views, user_id
  ORDER BY SUM(page_views) DESC LIMIT 10;
</code></pre>

    <p class="p">
      <code class="ph codeph">ORDER BY</code> is sometimes used in combination with <code class="ph codeph">OFFSET</code> and
      <code class="ph codeph">LIMIT</code> to paginate query results, although it is relatively inefficient to issue multiple
      queries like this against the large tables typically used with Impala:
    </p>


<pre class="pre codeblock"><code>SELECT page_title AS "Page 1 of search results", page_url FROM search_content
  WHERE LOWER(page_title) LIKE '%game%')
  ORDER BY page_title LIMIT 10 OFFSET 0;
SELECT page_title AS "Page 2 of search results", page_url FROM search_content
  WHERE LOWER(page_title) LIKE '%game%')
  ORDER BY page_title LIMIT 10 OFFSET 10;
SELECT page_title AS "Page 3 of search results", page_url FROM search_content
  WHERE LOWER(page_title) LIKE '%game%')
  ORDER BY page_title LIMIT 10 OFFSET 20;
</code></pre>

    <p class="p">
        <strong class="ph b">Internal details:</strong>
      </p>


    <p class="p"> Impala sorts the intermediate results of an <code class="ph codeph">ORDER BY</code>
      clause in memory whenever practical. In a cluster of N executor Impala
      daemons, each daemon sorts roughly 1/Nth of the result set, the exact
      proportion varying depending on how the data matching the query is
      distributed in HDFS. </p>


    <p class="p"> If the size of the sorted intermediate result set on any executor Impala
      daemon would cause the query to exceed the Impala memory limit, Impala
      sorts as much as practical in memory, then writes partially sorted data to
      disk. (This technique is known in industry terminology as <span class="q">"external
        sorting"</span> and <span class="q">"spilling to disk"</span>.) As each 8 MB batch of data is
      written to disk, Impala frees the corresponding memory to sort a new 8 MB
      batch of data. When all the data has been processed, a final merge sort
      operation is performed to correctly order the in-memory and on-disk
      results as the result set is transmitted back to the coordinator node.
      When external sorting becomes necessary, Impala requires approximately 60
      MB of RAM at a minimum for the buffers needed to read, write, and sort the
      intermediate results. If more RAM is available on the Impala daemon,
      Impala will use the additional RAM to minimize the amount of disk I/O for
      sorting. </p>


    <p class="p"> This external sort technique is used as appropriate on each Impala
      daemon (possibly including the coordinator node) to sort the portion of
      the result set that is processed on that node. When the sorted
      intermediate results are sent back to the coordinator node to produce the
      final result set, the coordinator node uses a merge sort technique to
      produce a final sorted result set without using any extra resources on the
      coordinator node. </p>


    <p class="p">
      <strong class="ph b">Configuration for disk usage:</strong>
    </p>


    <p class="p">
        By default, intermediate files used during large sort, join, aggregation, or analytic
        function operations are stored in the directory <span class="ph filepath">/tmp/impala-scratch</span>
        . These files are removed when the operation finishes. (Multiple concurrent queries can
        perform operations that use the <span class="q">"spill to disk"</span> technique, without any name
        conflicts for these temporary files.) You can specify a different location by starting
        the <span class="keyword cmdname">impalad</span> daemon with the
        <code class="ph codeph">‑‑scratch_dirs="<var class="keyword varname">path_to_directory</var>"</code>
        configuration option. You can specify a single directory, or a comma-separated list of
        directories. The scratch directories must be on the local filesystem, not in HDFS. You
        might specify different directory paths for different hosts, depending on the capacity
        and speed of the available storage devices. In <span class="keyword">Impala 2.3</span> or
        higher, Impala successfully starts (with a warning Impala successfully starts (with a
        warning written to the log) if it cannot create or read and write files in one of the
        scratch directories. If there is less than 1 GB free on the filesystem where that
        directory resides, Impala still runs, but writes a warning message to its log. If Impala
        encounters an error reading or writing files in a scratch directory during a query,
        Impala logs the error and the query fails.
      </p>


    <p class="p">
        <strong class="ph b">Sorting considerations:</strong> Although you can specify an <code class="ph codeph">ORDER BY</code>
        clause in an <code class="ph codeph">INSERT ... SELECT</code> statement, any <code class="ph codeph">ORDER BY</code>
        clause is ignored and the results are not necessarily sorted. An <code class="ph codeph">INSERT ...
        SELECT</code> operation potentially creates many different data files, prepared by
        different executor Impala daemons, and therefore the notion of the data being stored in
        sorted order is impractical.
      </p>


    <div class="p">
        An <code class="ph codeph">ORDER BY</code> clause without an additional <code class="ph codeph">LIMIT</code> clause
        is ignored in any view definition. If you need to sort the entire result set from a
        view, use an <code class="ph codeph">ORDER BY</code> clause in the <code class="ph codeph">SELECT</code> statement
        that queries the view. You can still make a simple <span class="q">"top 10"</span> report by combining the
        <code class="ph codeph">ORDER BY</code> and <code class="ph codeph">LIMIT</code> clauses in the same view
        definition:
<pre class="pre codeblock"><code>[localhost:21000] &gt; create table unsorted (x bigint);
[localhost:21000] &gt; insert into unsorted values (1), (9), (3), (7), (5), (8), (4), (6), (2);
[localhost:21000] &gt; create view sorted_view as select x from unsorted order by x;
[localhost:21000] &gt; select x from sorted_view; -- ORDER BY clause in view has no effect.
+---+
| x |
+---+
| 1 |
| 9 |
| 3 |
| 7 |
| 5 |
| 8 |
| 4 |
| 6 |
| 2 |
+---+
[localhost:21000] &gt; select x from sorted_view order by x; -- View query requires ORDER BY at outermost level.
+---+
| x |
+---+
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |
+---+
[localhost:21000] &gt; create view top_3_view as select x from unsorted order by x limit 3;
[localhost:21000] &gt; select x from top_3_view; -- ORDER BY and LIMIT together in view definition are preserved.
+---+
| x |
+---+
| 1 |
| 2 |
| 3 |
+---+
</code></pre>
      </div>


    <p class="p">
      With the lifting of the requirement to include a <code class="ph codeph">LIMIT</code> clause in every <code class="ph codeph">ORDER
      BY</code> query (in Impala 1.4 and higher):
    </p>


    <ul class="ul">
      <li class="li">
        <p class="p"> Now the use of scratch disk space raises the possibility of an
            <span class="q">"out of disk space"</span> error on a particular Impala daemon, as
          opposed to the previous possibility of an <span class="q">"out of memory"</span> error.
          Make sure to keep at least 1 GB free on the filesystem used for
          temporary sorting work. </p>

      </li>


    </ul>


    <p class="p">
        In Impala 1.2.1 and higher, all <code class="ph codeph">NULL</code> values come at the end of the
        result set for <code class="ph codeph">ORDER BY ... ASC</code> queries, and at the beginning of the
        result set for <code class="ph codeph">ORDER BY ... DESC</code> queries. In effect,
        <code class="ph codeph">NULL</code> is considered greater than all other values for sorting purposes.
        The original Impala behavior always put <code class="ph codeph">NULL</code> values at the end, even
        for <code class="ph codeph">ORDER BY ... DESC</code> queries. The new behavior in Impala 1.2.1 makes
        Impala more compatible with other popular database systems. In Impala 1.2.1 and higher,
        you can override or specify the sorting behavior for <code class="ph codeph">NULL</code> by adding the
        clause <code class="ph codeph">NULLS FIRST</code> or <code class="ph codeph">NULLS LAST</code> at the end of the
        <code class="ph codeph">ORDER BY</code> clause.
      </p>

<pre class="pre codeblock"><code>[localhost:21000] &gt; create table numbers (x int);
[localhost:21000] &gt; insert into numbers values (1), (null), (2), (null), (3);
[localhost:21000] &gt; select x from numbers order by x nulls first;
+------+
| x    |
+------+
| NULL |
| NULL |
| 1    |
| 2    |
| 3    |
+------+
[localhost:21000] &gt; select x from numbers order by x desc nulls first;
+------+
| x    |
+------+
| NULL |
| NULL |
| 3    |
| 2    |
| 1    |
+------+
[localhost:21000] &gt; select x from numbers order by x nulls last;
+------+
| x    |
+------+
| 1    |
| 2    |
| 3    |
| NULL |
| NULL |
+------+
[localhost:21000] &gt; select x from numbers order by x desc nulls last;
+------+
| x    |
+------+
| 3    |
| 2    |
| 1    |
| NULL |
| NULL |
+------+
</code></pre>

    <p class="p">
        <strong class="ph b">Related information:</strong>
      </p>


    <p class="p">
      See <a class="xref" href="impala_select.html#select">SELECT Statement</a> for further examples of queries with the <code class="ph codeph">ORDER
      BY</code> clause.
    </p>


    <p class="p">
      Analytic functions use the <code class="ph codeph">ORDER BY</code> clause in a different context to define the sequence in
      which rows are analyzed. See <a class="xref" href="impala_analytic_functions.html#analytic_functions">Impala Analytic Functions</a> for details.
    </p>

  </div>

<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../topics/impala_select.html">SELECT Statement</a></div>
</div>
</div></body>
</html>