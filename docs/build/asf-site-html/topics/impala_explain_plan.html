<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="copyright" content="(C) Copyright 2023"><meta name="DC.rights.owner" content="(C) Copyright 2023"><meta name="DC.Type" content="concept"><meta name="DC.Relation" scheme="URI" content="../topics/impala_performance.html"><meta name="prodname" content="Impala"><meta name="prodname" content="Impala"><meta name="prodname" content="Impala"><meta name="prodname" content="Impala"><meta name="prodname" content="Impala"><meta name="version" content="Impala 3.4.x"><meta name="version" content="Impala 3.4.x"><meta name="version" content="Impala 3.4.x"><meta name="version" content="Impala 3.4.x"><meta name="version" content="Impala 3.4.x"><meta name="DC.Format" content="XHTML"><meta name="DC.Identifier" content="explain_plan"><link rel="stylesheet" type="text/css" href="../css/commonltr.css"><link rel="stylesheet" type="text/css" href="../css/dita-ot-doc.css"><title>Understanding Impala Query Performance - EXPLAIN Plans and Query Profiles</title></head><body id="explain_plan"><header role="banner"><!--
The DITA Open Toolkit is licensed for use under the the Apache
Software Foundation License v2.0.

A copy of the Apache Software Foundation License 2.0 is
available at http://opensource.org/licenses/apache2.0.php

This statement must be included in any copies of DITA Open
Toolkit code.
--><div class="header">
  <p>Apache Impala</p>
  <hr>
</div></header><nav role="toc"><ul><li><a href="../topics/impala_intro.html">Introducing Apache Impala</a></li><li><a href="../topics/impala_concepts.html">Concepts and Architecture</a></li><li><a href="../topics/impala_planning.html">Deployment Planning</a></li><li><a href="../topics/impala_install.html">Installing Impala</a></li><li><a href="../topics/impala_config.html">Managing Impala</a></li><li><a href="../topics/impala_upgrading.html">Upgrading Impala</a></li><li><a href="../topics/impala_processes.html">Starting Impala</a></li><li><a href="../topics/impala_tutorial.html">Tutorials</a></li><li><a href="../topics/impala_admin.html">Administration</a></li><li><a href="../topics/impala_security.html">Impala Security</a></li><li><a href="../topics/impala_langref.html">SQL Reference</a></li><li><a href="../topics/impala_performance.html">Performance Tuning</a><ul><li><a href="../topics/impala_perf_cookbook.html">Performance Best Practices</a></li><li><a href="../topics/impala_perf_joins.html">Join Performance</a></li><li><a href="../topics/impala_perf_stats.html">Table and Column Statistics</a></li><li><a href="../topics/impala_perf_benchmarking.html">Benchmarking</a></li><li><a href="../topics/impala_perf_resources.html">Controlling Resource Usage</a></li><li><a href="../topics/impala_runtime_filtering.html">Runtime Filtering</a></li><li><a href="../topics/impala_perf_hdfs_caching.html">HDFS Caching</a></li><li><a href="../topics/impala_perf_skew.html">HDFS Block Skew</a></li><li><a href="../topics/impala_data_cache.html">Data Cache for Remote Reads</a></li><li><a href="../topics/impala_perf_testing.html">Testing Impala Performance</a></li><li class="active"><a href="../topics/impala_explain_plan.html">EXPLAIN Plans and Query Profiles</a></li></ul></li><li><a href="../topics/impala_scalability.html">Scalability Considerations</a></li><li><a href="../topics/impala_resource_management.html">Resource Management</a></li><li><a href="../topics/impala_partitioning.html">Partitioning</a></li><li><a href="../topics/impala_file_formats.html">File Formats</a></li><li><a href="../topics/impala_kudu.html">Using Impala to Query Kudu Tables</a></li><li><a href="../topics/impala_hbase.html">HBase Tables</a></li><li><a href="../topics/impala_iceberg.html">Iceberg Tables</a></li><li><a href="../topics/impala_s3.html">S3 Tables</a></li><li><a href="../topics/impala_adls.html">ADLS Tables</a></li><li><a href="../topics/impala_isilon.html">Isilon Storage</a></li><li><a href="../topics/impala_ozone.html">Ozone Storage</a></li><li><a href="../topics/impala_logging.html">Logging</a></li><li><a href="../topics/impala_client.html">Client Access</a></li><li><a href="../topics/impala_fault_tolerance.html">Fault Tolerance</a></li><li><a href="../topics/impala_troubleshooting.html">Troubleshooting Impala</a></li><li><a href="../topics/impala_ports.html">Ports Used by Impala</a></li><li><a href="../topics/impala_reserved_words.html">Impala Reserved Words</a></li><li><a href="../topics/impala_faq.html">Impala Frequently Asked Questions</a></li><li><a href="../topics/impala_release_notes.html">Impala Release Notes</a></li></ul></nav><main role="main"><article role="article" aria-labelledby="ariaid-title1">

  <h1 class="title topictitle1" id="ariaid-title1">Understanding Impala Query Performance - EXPLAIN Plans and Query Profiles</h1>

  

  

  <div class="body conbody">

    <p class="p">
      To understand the high-level performance considerations for Impala queries, read the
      output of the <code class="ph codeph">EXPLAIN</code> statement for the query. You can get the
      <code class="ph codeph">EXPLAIN</code> plan without actually running the query itself.
    </p>

    <p class="p">
      For an overview of the physical performance characteristics for a query, issue the
      <code class="ph codeph">SUMMARY</code> statement in <span class="keyword cmdname">impala-shell</span> immediately after
      executing a query. This condensed information shows which phases of execution took the
      most time, and how the estimates for memory usage and number of rows at each phase compare
      to the actual values.
    </p>

    <p class="p">
      To understand the detailed performance characteristics for a query, issue the
      <code class="ph codeph">PROFILE</code> statement in <span class="keyword cmdname">impala-shell</span> immediately after
      executing a query. This low-level information includes physical details about memory, CPU,
      I/O, and network usage, and thus is only available after the query is actually run.
    </p>

    <p class="p toc inpage"></p>

    <p class="p">
      Also, see <a class="xref" href="impala_hbase.html#hbase_performance">Performance Considerations for the Impala-HBase Integration</a> and
      <a class="xref" href="impala_s3.html#s3_performance">Understanding and Tuning Impala Query Performance for S3 Data</a> for examples of interpreting
      <code class="ph codeph">EXPLAIN</code> plans for queries against HBase tables <span class="ph">and data
      stored in the Amazon Simple Storage System (S3)</span>.
    </p>

  </div>

  <nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../topics/impala_performance.html">Tuning Impala for Performance</a></div></div></nav><article class="topic concept nested1" aria-labelledby="ariaid-title2" id="explain_plan__perf_explain">

    <h2 class="title topictitle2" id="ariaid-title2">Using the EXPLAIN Plan for Performance Tuning</h2>

    <div class="body conbody">

      <p class="p">
        The <code class="ph codeph"><a class="xref" href="impala_explain.html#explain">EXPLAIN</a></code> statement
        gives you an outline of the logical steps that a query will perform, such as how the
        work will be distributed among the nodes and how intermediate results will be combined
        to produce the final result set. You can see these details before actually running the
        query. You can use this information to check that the query will not operate in some
        very unexpected or inefficient way.
      </p>



<pre class="pre codeblock"><code>[impalad-host:21000] &gt; EXPLAIN SELECT COUNT(*) FROM customer_address;
+----------------------------------------------------------+
| Explain String                                           |
+----------------------------------------------------------+
| ...                                                      |
|                                                          |
| 03:AGGREGATE [FINALIZE]                                  |
| |  output: sum(count(*))                                 |
| |                                                        |
| 02:EXCHANGE [UNPARTITIONED]                              |
| |                                                        |
| 01:AGGREGATE                                             |
| |  output: count(*)                                      |
| |                                                        |
| 00:SCAN HDFS [default.customer_address]                  |
|    partitions=1/1 size=5.25MB                            |
+----------------------------------------------------------+
</code></pre>

      <div class="p">
        Read the <code class="ph codeph">EXPLAIN</code> plan from bottom to top:
        <ul class="ul">
          <li class="li">
            The last part of the plan shows the low-level details such as the expected amount of
            data that will be read, where you can judge the effectiveness of your partitioning
            strategy and estimate how long it will take to scan a table based on total data size
            and the size of the cluster.
          </li>

          <li class="li">
            As you work your way up, next you see the operations that will be parallelized and
            performed on each Impala node.
          </li>

          <li class="li">
            At the higher levels, you see how data flows when intermediate result sets are
            combined and transmitted from one node to another.
          </li>

          <li class="li">
            See <a class="xref" href="../shared/../topics/impala_explain_level.html#explain_level">EXPLAIN_LEVEL Query Option</a> for details
            about the <code class="ph codeph">EXPLAIN_LEVEL</code> query option, which lets you customize how
            much detail to show in the <code class="ph codeph">EXPLAIN</code> plan depending on whether you
            are doing high-level or low-level tuning, dealing with logical or physical aspects
            of the query.
          </li>
        </ul>
      </div>

      <p class="p">
        The <code class="ph codeph">EXPLAIN</code> plan is also printed at the beginning of the query profile
        report described in <a class="xref" href="#perf_profile">Using the Query Profile for Performance Tuning</a>, for convenience in examining both the
        logical and physical aspects of the query side-by-side.
      </p>

      <p class="p">
        The amount of detail displayed in the <code class="ph codeph">EXPLAIN</code> output is controlled by
        the <a class="xref" href="impala_explain_level.html#explain_level">EXPLAIN_LEVEL</a> query
        option. You typically increase this setting from <code class="ph codeph">standard</code> to
        <code class="ph codeph">extended</code> (or from <code class="ph codeph">1</code> to <code class="ph codeph">2</code>) when
        doublechecking the presence of table and column statistics during performance tuning, or
        when estimating query resource usage in conjunction with the resource management
        features.
      </p>



    </div>

  </article>

  <article class="topic concept nested1" aria-labelledby="ariaid-title3" id="explain_plan__perf_summary">

    <h2 class="title topictitle2" id="ariaid-title3">Using the SUMMARY Report for Performance Tuning</h2>

    <div class="body conbody">

      <p class="p">
        The
        <code class="ph codeph"><a class="xref" href="impala_shell_commands.html#shell_commands">SUMMARY</a></code>
        command within the <span class="keyword cmdname">impala-shell</span> interpreter gives you an
        easy-to-digest overview of the timings for the different phases of execution for a
        query. Like the <code class="ph codeph">EXPLAIN</code> plan, it is easy to see potential performance
        bottlenecks. Like the <code class="ph codeph">PROFILE</code> output, it is available after the query
        is run and so displays actual timing numbers.
      </p>

      <p class="p">
        The <code class="ph codeph">SUMMARY</code> report is also printed at the beginning of the query
        profile report described in <a class="xref" href="#perf_profile">Using the Query Profile for Performance Tuning</a>, for convenience in examining
        high-level and low-level aspects of the query side-by-side.
      </p>

      <p class="p">
        When the <code class="ph codeph">MT_DOP</code> query option is set to a value larger than
        <code class="ph codeph">0</code>, the <code class="ph codeph">#Inst</code> column in the output shows the number of
        fragment instances. Impala decomposes each query into smaller units of work that are
        distributed across the cluster, and these units are referred as fragments.
      </p>

      <p class="p">
        When the <code class="ph codeph">MT_DOP</code> query option is set to 0, the <code class="ph codeph">#Inst</code>
        column in the output shows the same value as the <code class="ph codeph">#Hosts</code> column, since
        there is exactly one fragment for each host.
      </p>

      <p class="p">
        For example, here is a query involving an aggregate function, on a single-node cluster.
        The different stages of the query and their timings are shown (rolled up for all nodes),
        along with estimated and actual values used in planning the query. In this case, the
        <code class="ph codeph">AVG()</code> function is computed for a subset of data on each node (stage 01)
        and then the aggregated results from all nodes are combined at the end (stage 03). You
        can see which stages took the most time, and whether any estimates were substantially
        different than the actual data distribution.
      </p>

<pre class="pre codeblock"><code>&gt; SELECT AVG(ss_sales_price) FROM store_sales WHERE ss_coupon_amt = 0;
&gt; SUMMARY;
+--------------+--------+--------+----------+----------+-------+------------+----------+---------------+-----------------+
| Operator     | #Hosts | #Inst  | Avg Time | Max Time | #Rows | Est. #Rows | Peak Mem | Est. Peak Mem | Detail          |
+--------------+--------+--------+----------+----------+-------+------------+----------+---------------+-----------------+
| 03:AGGREGATE | 1      | 1      | 1.03ms   | 1.03ms   | 1     | 1          | 48.00 KB | -1 B          | MERGE FINALIZE  |
| 02:EXCHANGE  | 1      | 1      | 0ns      | 0ns      | 1     | 1          | 0 B      | -1 B          | UNPARTITIONED   |
| 01:AGGREGATE | 1      | 1      |30.79ms   | 30.79ms  | 1     | 1          | 80.00 KB | 10.00 MB      |                 |
| 00:SCAN HDFS | 1      | 1      | 5.45s    | 5.45s    | 2.21M | -1         | 64.05 MB | 432.00 MB     | tpc.store_sales |
+--------------+--------+--------+----------+----------+-------+------------+----------+---------------+-----------------+
</code></pre>

      <p class="p">
        Notice how the longest initial phase of the query is measured in seconds (s), while
        later phases working on smaller intermediate results are measured in milliseconds (ms)
        or even nanoseconds (ns).
      </p>

    </div>

  </article>

  <article class="topic concept nested1" aria-labelledby="ariaid-title4" id="explain_plan__perf_profile">

    <h2 class="title topictitle2" id="ariaid-title4">Using the Query Profile for Performance Tuning</h2>

    <div class="body conbody">

      <p class="p">
        The <code class="ph codeph">PROFILE</code> command, available in the <span class="keyword cmdname">impala-shell</span>
        interpreter, produces a detailed low-level report showing how the most recent query was
        executed. Unlike the <code class="ph codeph">EXPLAIN</code> plan described in
        <a class="xref" href="#perf_explain">Using the EXPLAIN Plan for Performance Tuning</a>, this information is only available after the
        query has finished. It shows physical details such as the number of bytes read, maximum
        memory usage, and so on for each node. You can use this information to determine if the
        query is I/O-bound or CPU-bound, whether some network condition is imposing a
        bottleneck, whether a slowdown is affecting some nodes but not others, and to check that
        recommended configuration settings such as short-circuit local reads are in effect.
      </p>

      <p class="p">
        By default, time values in the profile output reflect the wall-clock time taken by an
        operation. For values denoting system time or user time, the measurement unit is
        reflected in the metric name, such as <code class="ph codeph">ScannerThreadsSysTime</code> or
        <code class="ph codeph">ScannerThreadsUserTime</code>. For example, a multi-threaded I/O operation
        might show a small figure for wall-clock time, while the corresponding system time is
        larger, representing the sum of the CPU time taken by each thread. Or a wall-clock time
        figure might be larger because it counts time spent waiting, while the corresponding
        system and user time figures only measure the time while the operation is actively using
        CPU cycles.
      </p>

      <p class="p">
        The <a class="xref" href="impala_explain_plan.html#perf_explain"><code class="ph codeph">EXPLAIN</code>
        plan</a> is also printed at the beginning of the query profile report, for
        convenience in examining both the logical and physical aspects of the query
        side-by-side. The
        <a class="xref" href="impala_explain_level.html#explain_level">EXPLAIN_LEVEL</a> query option
        also controls the verbosity of the <code class="ph codeph">EXPLAIN</code> output printed by the
        <code class="ph codeph">PROFILE</code> command.
      </p>

      <p class="p">
        In <span class="keyword">Impala 3.2</span>, a new <code class="ph codeph">Per Node Profiles</code> section
        was added to the profile output. The new section includes the following metrics that can
        be controlled by the
        <code class="ph codeph"><a class="xref" href="impala_resource_trace_ratio.html#resource_trace_ratio">RESOURCE_TRACE_RATIO</a></code>
        query option.
      </p>

      <ul class="ul">
        <li class="li">
          <code class="ph codeph">CpuIoWaitPercentage</code>
        </li>

        <li class="li">
          <code class="ph codeph">CpuSysPercentage</code>
        </li>

        <li class="li">
          <code class="ph codeph">CpuUserPercentage</code>
        </li>

        <li class="li">
          <code class="ph codeph">HostDiskReadThroughput</code>: All data read by the host as part of the
          execution of this query (spilling), by the HDFS data node, and by other processes
          running on the same system.
        </li>

        <li class="li">
          <code class="ph codeph">HostDiskWriteThroughput</code>: All data written by the host as part of the
          execution of this query (spilling), by the HDFS data node, and by other processes
          running on the same system.
        </li>

        <li class="li">
          <code class="ph codeph">HostNetworkRx</code>: All data received by the host as part of the execution
          of this query, other queries, and other processes running on the same system.
        </li>

        <li class="li">
          <code class="ph codeph">HostNetworkTx</code>: All data transmitted by the host as part of the
          execution of this query, other queries, and other processes running on the same
          system.
        </li>
      </ul>

    </div>

  </article>

</article></main></body></html>