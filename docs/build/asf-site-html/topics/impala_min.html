<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="copyright" content="(C) Copyright 2024"><meta name="DC.rights.owner" content="(C) Copyright 2024"><meta name="DC.Type" content="concept"><meta name="DC.Relation" scheme="URI" content="../topics/impala_aggregate_functions.html"><meta name="prodname" content="Impala"><meta name="prodname" content="Impala"><meta name="version" content="Impala 3.4.x"><meta name="version" content="Impala 3.4.x"><meta name="DC.Format" content="XHTML"><meta name="DC.Identifier" content="min"><link rel="stylesheet" type="text/css" href="../css/commonltr.css"><link rel="stylesheet" type="text/css" href="../css/dita-ot-doc.css"><title>MIN Function</title></head><body id="min"><header role="banner"><!--
The DITA Open Toolkit is licensed for use under the the Apache
Software Foundation License v2.0.

A copy of the Apache Software Foundation License 2.0 is
available at http://opensource.org/licenses/apache2.0.php

This statement must be included in any copies of DITA Open
Toolkit code.
--><div class="header">
  <p>Apache Impala</p>
  <hr>
</div></header><nav role="toc"><ul><li><a href="../topics/impala_intro.html">Introducing Apache Impala</a></li><li><a href="../topics/impala_concepts.html">Concepts and Architecture</a></li><li><a href="../topics/impala_planning.html">Deployment Planning</a></li><li><a href="../topics/impala_install.html">Installing Impala</a></li><li><a href="../topics/impala_config.html">Managing Impala</a></li><li><a href="../topics/impala_upgrading.html">Upgrading Impala</a></li><li><a href="../topics/impala_processes.html">Starting Impala</a></li><li><a href="../topics/impala_tutorial.html">Tutorials</a></li><li><a href="../topics/impala_admin.html">Administration</a></li><li><a href="../topics/impala_security.html">Impala Security</a></li><li><a href="../topics/impala_langref.html">SQL Reference</a><ul><li><a href="../topics/impala_comments.html">Comments</a></li><li><a href="../topics/impala_datatypes.html">Data Types</a></li><li><a href="../topics/impala_literals.html">Literals</a></li><li><a href="../topics/impala_operators.html">SQL Operators</a></li><li><a href="../topics/impala_schema_objects.html">Schema Objects and Object Names</a></li><li><a href="../topics/impala_transactions.html">Transactions</a></li><li><a href="../topics/impala_langref_sql.html">SQL Statements</a></li><li><a href="../topics/impala_functions.html">Built-In Functions</a><ul><li><a href="../topics/impala_math_functions.html">Mathematical Functions</a></li><li><a href="../topics/impala_bit_functions.html">Bit Functions</a></li><li><a href="../topics/impala_conversion_functions.html">Type Conversion Functions</a></li><li><a href="../topics/impala_datetime_functions.html">Date and Time Functions</a></li><li><a href="../topics/impala_conditional_functions.html">Conditional Functions</a></li><li><a href="../topics/impala_string_functions.html">String Functions</a></li><li><a href="../topics/impala_misc_functions.html">Miscellaneous Functions</a></li><li><a href="../topics/impala_aggregate_functions.html">Aggregate Functions</a><ul><li><a href="../topics/impala_appx_median.html">APPX_MEDIAN</a></li><li><a href="../topics/impala_avg.html">AVG</a></li><li><a href="../topics/impala_count.html">COUNT</a></li><li><a href="../topics/impala_group_concat.html">GROUP_CONCAT</a></li><li><a href="../topics/impala_max.html">MAX</a></li><li class="active"><a href="../topics/impala_min.html">MIN</a></li><li><a href="../topics/impala_ndv.html">NDV</a></li><li><a href="../topics/impala_stddev.html">STDDEV, STDDEV_SAMP, STDDEV_POP</a></li><li><a href="../topics/impala_sum.html">SUM</a></li><li><a href="../topics/impala_variance.html">VARIANCE, VARIANCE_SAMP, VARIANCE_POP, VAR_SAMP, VAR_POP</a></li></ul></li><li><a href="../topics/impala_analytic_functions.html">Analytic Functions</a></li></ul></li><li><a href="../topics/impala_udf.html">User-Defined Functions (UDFs)</a></li><li><a href="../topics/impala_langref_unsupported.html">SQL Differences Between Impala and Hive</a></li><li><a href="../topics/impala_porting.html">Porting SQL</a></li><li><a href="../topics/impala_utf_8.html">UTF-8 Support</a></li></ul></li><li><a href="../topics/impala_performance.html">Performance Tuning</a></li><li><a href="../topics/impala_scalability.html">Scalability Considerations</a></li><li><a href="../topics/impala_resource_management.html">Resource Management</a></li><li><a href="../topics/impala_partitioning.html">Partitioning</a></li><li><a href="../topics/impala_file_formats.html">File Formats</a></li><li><a href="../topics/impala_kudu.html">Using Impala to Query Kudu Tables</a></li><li><a href="../topics/impala_hbase.html">HBase Tables</a></li><li><a href="../topics/impala_iceberg.html">Iceberg Tables</a></li><li><a href="../topics/impala_s3.html">S3 Tables</a></li><li><a href="../topics/impala_adls.html">ADLS Tables</a></li><li><a href="../topics/impala_isilon.html">Isilon Storage</a></li><li><a href="../topics/impala_ozone.html">Ozone Storage</a></li><li><a href="../topics/impala_logging.html">Logging</a></li><li><a href="../topics/impala_client.html">Client Access</a></li><li><a href="../topics/impala_fault_tolerance.html">Fault Tolerance</a></li><li><a href="../topics/impala_troubleshooting.html">Troubleshooting Impala</a></li><li><a href="../topics/impala_ports.html">Ports Used by Impala</a></li><li><a href="../topics/impala_reserved_words.html">Impala Reserved Words</a></li><li><a href="../topics/impala_faq.html">Impala Frequently Asked Questions</a></li><li><a href="../topics/impala_release_notes.html">Impala Release Notes</a></li></ul></nav><main role="main"><article role="article" aria-labelledby="ariaid-title1">

  <h1 class="title topictitle1" id="ariaid-title1">MIN Function</h1>
  
  

  <div class="body conbody">

    <p class="p">
      
      An aggregate function that returns the minimum value from a set of numbers. Opposite of the
      <code class="ph codeph">MAX</code> function. Its single argument can be numeric column, or the numeric result of a function
      or expression applied to the column value. Rows with a <code class="ph codeph">NULL</code> value for the specified column
      are ignored. If the table is empty, or all the values supplied to <code class="ph codeph">MIN</code> are
      <code class="ph codeph">NULL</code>, <code class="ph codeph">MIN</code> returns <code class="ph codeph">NULL</code>.
    </p>

    <p class="p">
        <strong class="ph b">Syntax:</strong>
      </p>

<pre class="pre codeblock"><code>MIN([DISTINCT | ALL] <var class="keyword varname">expression</var>) [OVER (<var class="keyword varname">analytic_clause</var>)]</code></pre>

    <p class="p">
      When the query contains a <code class="ph codeph">GROUP BY</code> clause, returns one value for each combination of
      grouping values.
    </p>

    <p class="p">
        <strong class="ph b">Restrictions:</strong> In Impala 2.0 and higher, this function can be used as an analytic
        function, but with restrictions on any window clause. For <code class="ph codeph">MAX()</code> and
        <code class="ph codeph">MIN()</code>, the window clause is only allowed if the start bound is
        <code class="ph codeph">UNBOUNDED PRECEDING</code>.
      </p>

    <p class="p">
        <strong class="ph b">Return type:</strong> Same as the input value, except for <code class="ph codeph">CHAR</code> and
        <code class="ph codeph">VARCHAR</code> arguments which produce a <code class="ph codeph">STRING</code> result
      </p>

    <p class="p">
        <strong class="ph b">Usage notes:</strong>
      </p>

    <p class="p">
        If you frequently run aggregate functions such as <code class="ph codeph">MIN()</code>,
        <code class="ph codeph">MAX()</code>, and <code class="ph codeph">COUNT(DISTINCT)</code> on partition key columns,
        consider enabling the <code class="ph codeph">OPTIMIZE_PARTITION_KEY_SCANS</code> query option, which
        optimizes such queries. This feature is available in <span class="keyword">Impala 2.5</span>
        and higher. See <a class="xref" href="../shared/../topics/impala_optimize_partition_key_scans.html">OPTIMIZE_PARTITION_KEY_SCANS Query Option (Impala 2.5 or higher only)</a> for the
        kinds of queries that this option applies to, and slight differences in how partitions
        are evaluated when this query option is enabled.
      </p>

    <p class="p">
        <strong class="ph b">Complex type considerations:</strong>
      </p>

    <p class="p">
        To access a column with a complex type (<code class="ph codeph">ARRAY</code>, <code class="ph codeph">STRUCT</code>,
        or <code class="ph codeph">MAP</code>) in an aggregation function, you unpack the individual elements
        using join notation in the query, and then apply the function to the final scalar item,
        field, key, or value at the bottom of any nested type hierarchy in the column. See
        <a class="xref" href="../shared/../topics/impala_complex_types.html#complex_types">Complex Types (Impala 2.3 or higher only)</a> for details about using
        complex types in Impala.
      </p>

    <div class="p">
        The following example demonstrates calls to several aggregation functions using values
        from a column containing nested complex types (an <code class="ph codeph">ARRAY</code> of
        <code class="ph codeph">STRUCT</code> items). The array is unpacked inside the query using join
        notation. The array elements are referenced using the <code class="ph codeph">ITEM</code>
        pseudocolumn, and the structure fields inside the array elements are referenced using
        dot notation. Numeric values such as <code class="ph codeph">SUM()</code> and <code class="ph codeph">AVG()</code>
        are computed using the numeric <code class="ph codeph">R_NATIONKEY</code> field, and the
        general-purpose <code class="ph codeph">MAX()</code> and <code class="ph codeph">MIN()</code> values are computed
        from the string <code class="ph codeph">N_NAME</code> field.
<pre class="pre codeblock"><code>describe region;
+-------------+-------------------------+---------+
| name        | type                    | comment |
+-------------+-------------------------+---------+
| r_regionkey | smallint                |         |
| r_name      | string                  |         |
| r_comment   | string                  |         |
| r_nations   | array&lt;struct&lt;           |         |
|             |   n_nationkey:smallint, |         |
|             |   n_name:string,        |         |
|             |   n_comment:string      |         |
|             | &gt;&gt;                      |         |
+-------------+-------------------------+---------+

select r_name, r_nations.item.n_nationkey
  from region, region.r_nations as r_nations
order by r_name, r_nations.item.n_nationkey;
+-------------+------------------+
| r_name      | item.n_nationkey |
+-------------+------------------+
| AFRICA      | 0                |
| AFRICA      | 5                |
| AFRICA      | 14               |
| AFRICA      | 15               |
| AFRICA      | 16               |
| AMERICA     | 1                |
| AMERICA     | 2                |
| AMERICA     | 3                |
| AMERICA     | 17               |
| AMERICA     | 24               |
| ASIA        | 8                |
| ASIA        | 9                |
| ASIA        | 12               |
| ASIA        | 18               |
| ASIA        | 21               |
| EUROPE      | 6                |
| EUROPE      | 7                |
| EUROPE      | 19               |
| EUROPE      | 22               |
| EUROPE      | 23               |
| MIDDLE EAST | 4                |
| MIDDLE EAST | 10               |
| MIDDLE EAST | 11               |
| MIDDLE EAST | 13               |
| MIDDLE EAST | 20               |
+-------------+------------------+

select
  r_name,
  count(r_nations.item.n_nationkey) as count,
  sum(r_nations.item.n_nationkey) as sum,
  avg(r_nations.item.n_nationkey) as avg,
  min(r_nations.item.n_name) as minimum,
  max(r_nations.item.n_name) as maximum,
  ndv(r_nations.item.n_nationkey) as distinct_vals
from
  region, region.r_nations as r_nations
group by r_name
order by r_name;
+-------------+-------+-----+------+-----------+----------------+---------------+
| r_name      | count | sum | avg  | minimum   | maximum        | distinct_vals |
+-------------+-------+-----+------+-----------+----------------+---------------+
| AFRICA      | 5     | 50  | 10   | ALGERIA   | MOZAMBIQUE     | 5             |
| AMERICA     | 5     | 47  | 9.4  | ARGENTINA | UNITED STATES  | 5             |
| ASIA        | 5     | 68  | 13.6 | CHINA     | VIETNAM        | 5             |
| EUROPE      | 5     | 77  | 15.4 | FRANCE    | UNITED KINGDOM | 5             |
| MIDDLE EAST | 5     | 58  | 11.6 | EGYPT     | SAUDI ARABIA   | 5             |
+-------------+-------+-----+------+-----------+----------------+---------------+
</code></pre>
      </div>

    <p class="p">
        <strong class="ph b">Examples:</strong>
      </p>

<pre class="pre codeblock"><code>-- Find the smallest value for this column in the table.
select min(c1) from t1;
-- Find the smallest value for this column from a subset of the table.
select min(c1) from t1 where month = 'January' and year = '2013';
-- Find the smallest value from a set of numeric function results.
select min(length(s)) from t1;
-- Can also be used in combination with DISTINCT and/or GROUP BY.
-- Return more than one result.
select month, year, min(purchase_price) from store_stats group by month, year;
-- Filter the input to eliminate duplicates before performing the calculation.
select min(distinct x) from t1;
</code></pre>

    <div class="p">
      The following examples show how to use <code class="ph codeph">MIN()</code> in an analytic context. They use a table
      containing integers from 1 to 10. Notice how the <code class="ph codeph">MIN()</code> is reported for each input value, as
      opposed to the <code class="ph codeph">GROUP BY</code> clause which condenses the result set.
<pre class="pre codeblock"><code>select x, property, min(x) over (partition by property) as min from int_t where property in ('odd','even');
+----+----------+-----+
| x  | property | min |
+----+----------+-----+
| 2  | even     | 2   |
| 4  | even     | 2   |
| 6  | even     | 2   |
| 8  | even     | 2   |
| 10 | even     | 2   |
| 1  | odd      | 1   |
| 3  | odd      | 1   |
| 5  | odd      | 1   |
| 7  | odd      | 1   |
| 9  | odd      | 1   |
+----+----------+-----+
</code></pre>

Adding an <code class="ph codeph">ORDER BY</code> clause lets you experiment with results that are cumulative or apply to a moving
set of rows (the <span class="q">"window"</span>). The following examples use <code class="ph codeph">MIN()</code> in an analytic context
(that is, with an <code class="ph codeph">OVER()</code> clause) to display the smallest value of <code class="ph codeph">X</code>
encountered up to each row in the result set. The examples use two columns in the <code class="ph codeph">ORDER BY</code>
clause to produce a sequence of values that rises and falls, to illustrate how the <code class="ph codeph">MIN()</code>
result only decreases or stays the same throughout each partition within the result set.
The basic <code class="ph codeph">ORDER BY x</code> clause implicitly
activates a window clause of <code class="ph codeph">RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>,
which is effectively the same as <code class="ph codeph">ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>,
therefore all of these examples produce the same results:

<pre class="pre codeblock"><code>select x, property, min(x) <strong class="ph b">over (order by property, x desc)</strong> as 'minimum to this point'
  from int_t where property in ('prime','square');
+---+----------+-----------------------+
| x | property | minimum to this point |
+---+----------+-----------------------+
| 7 | prime    | 7                     |
| 5 | prime    | 5                     |
| 3 | prime    | 3                     |
| 2 | prime    | 2                     |
| 9 | square   | 2                     |
| 4 | square   | 2                     |
| 1 | square   | 1                     |
+---+----------+-----------------------+

select x, property,
  min(x) over
  (
    <strong class="ph b">order by property, x desc</strong>
    <strong class="ph b">range between unbounded preceding and current row</strong>
  ) as 'minimum to this point'
from int_t where property in ('prime','square');
+---+----------+-----------------------+
| x | property | minimum to this point |
+---+----------+-----------------------+
| 7 | prime    | 7                     |
| 5 | prime    | 5                     |
| 3 | prime    | 3                     |
| 2 | prime    | 2                     |
| 9 | square   | 2                     |
| 4 | square   | 2                     |
| 1 | square   | 1                     |
+---+----------+-----------------------+

select x, property,
  min(x) over
  (
    <strong class="ph b">order by property, x desc</strong>
    <strong class="ph b">rows between unbounded preceding and current row</strong>
  ) as 'minimum to this point'
from int_t where property in ('prime','square');
+---+----------+-----------------------+
| x | property | minimum to this point |
+---+----------+-----------------------+
| 7 | prime    | 7                     |
| 5 | prime    | 5                     |
| 3 | prime    | 3                     |
| 2 | prime    | 2                     |
| 9 | square   | 2                     |
| 4 | square   | 2                     |
| 1 | square   | 1                     |
+---+----------+-----------------------+
</code></pre>

The following examples show how to construct a moving window, with a running minimum taking into account all rows before
and 1 row after the current row.
Because of a restriction in the Impala <code class="ph codeph">RANGE</code> syntax, this type of
moving window is possible with the <code class="ph codeph">ROWS BETWEEN</code> clause but not the <code class="ph codeph">RANGE BETWEEN</code> clause.
Because of an extra Impala restriction on the <code class="ph codeph">MAX()</code> and <code class="ph codeph">MIN()</code> functions in an
analytic context, the lower bound must be <code class="ph codeph">UNBOUNDED PRECEDING</code>.
<pre class="pre codeblock"><code>select x, property,
  min(x) over
  (
    <strong class="ph b">order by property, x desc</strong>
    <strong class="ph b">rows between unbounded preceding and 1 following</strong>
  ) as 'local minimum'
from int_t where property in ('prime','square');
+---+----------+---------------+
| x | property | local minimum |
+---+----------+---------------+
| 7 | prime    | 5             |
| 5 | prime    | 3             |
| 3 | prime    | 2             |
| 2 | prime    | 2             |
| 9 | square   | 2             |
| 4 | square   | 1             |
| 1 | square   | 1             |
+---+----------+---------------+

-- Doesn't work because of syntax restriction on RANGE clause.
select x, property,
  min(x) over
  (
    <strong class="ph b">order by property, x desc</strong>
    <strong class="ph b">range between unbounded preceding and 1 following</strong>
  ) as 'local minimum'
from int_t where property in ('prime','square');
ERROR: AnalysisException: RANGE is only supported with both the lower and upper bounds UNBOUNDED or one UNBOUNDED and the other CURRENT ROW.
</code></pre>
    </div>

    <p class="p">
        <strong class="ph b">Related information:</strong>
      </p>

    <p class="p">
      <a class="xref" href="impala_analytic_functions.html#analytic_functions">Impala Analytic Functions</a>, <a class="xref" href="impala_max.html#max">MAX Function</a>,
      <a class="xref" href="impala_avg.html#avg">AVG Function</a>
    </p>
  </div>
<nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../topics/impala_aggregate_functions.html">Impala Aggregate Functions</a></div></div></nav></article></main></body></html>